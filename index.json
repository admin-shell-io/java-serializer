{
  "api/index.html": {
    "href": "api/index.html",
    "title": "API Documentation",
    "keywords": "API Documentation This is automatically-generated documentation of the API extracted from the structured comments in the code base. Documentation Quality We are aware that the current generated documentation might be confusing or overwhelming for the new developers since it still lacks structure and no entry points are clearly visible. At the moment (August 2020), we are working on an introductory document to give you an overview of the code structure and how individual parts fit together. Entry Point Current entry point to the program is: AasxPackageExplorer.App . This class parses the command-line arguments and instantiates the AasxPackageExplorer.MainWindow . The graphical user interface (GUI) is implemented in the namespace AasxPackageExplorer . Data Model The data model of the AASX lives in the AdminShellNS namespace. Any changes and extensions to the data model should go there. Since the data model is still evolving (August 2020), we put the code responsible for managing the legacy data models ( e.g. , AASX V1.0) to the namespace AasxCompatibilityModels . The pre-defined concepts (such as VDI 2770 ) reside in the namespace AasxPredefinedConcepts . Package Signatures Package signatures ( e.g. , using X.509 standard) are handled in the namespace AasxSignature . Clients AASX Package Explorer uses various clients to communicate with the external sources. The clients are compartmentalized in the individual *Client namespaces ( e.g. , AasxMqttClient and AasxOpenIdClient ). Imports and Exports Imports and exports from different data formats are handled in *ImExport namespaces such as AasxAmlImExport and AasxUANodesetImExport . Plug-ins AASX Package Explorer uses plug-ins to reduce the size of the different binary releases. For example, a plug-in web browser ( AasxPluginWebBrowser ) is pretty heavy in size (about 60 Mb), but many users do not actually need it. Hence they can download a much skinnier release without the browser (only about 2 Mb). The namespace AasxIntegrationBase provides all the functionality needed to integrate the plug-ins. AasxToolkit Program Apart from the main AASX Package Explorer, we include an additional program, AasxToolkit , to generate and manipulate AASX packages from the command line. This program is also a good entry point if you want to see how you can perform operations on AASX in code (rather than using a GUI tool). What is a REST Server Doing Here? It might seem confusing that we include a REST server in the application ( AasxRestConsoleServer and AasxRestServerLibrary ). The rationale behind this inclusion is to make the demonstrations and local tests simple & easy. However, from the software engineering point of view, this code does not really belong to the Package Explorer and should be refactored out of it. We are currently (August 2020) working on packaging AASX Server in such a way that AASX Package Explorer can use it directly as a dependency ( e.g. , as a NuGet package). As soon as we packaged the AASX Server, we will remove these server-related bits from this code base."
  },
  "getting-started/continuous-integration.html": {
    "href": "getting-started/continuous-integration.html",
    "title": "Continuous Integration",
    "keywords": "Continuous Integration To establish confidence in the software as well as to continuously maintain the code quality, we provide scripts to run pre-merge checks on your local machine as well as Github workflows to run remotely. All the following scripts should not require any administration privilege. Building for Debug To build the solution for debugging and testing, invoke: .\\src\\BuildForDebug.ps1 You can also build a single project. This is practical when you want to manually test something and do not want to waste time on MSBuild inspecting which projects need to be rebuilt: .\\src\\BuildForDebug.ps1 -Project AasxToolkit To clean the build, call: .\\src\\BuildForDebug.ps1 -clean In cases of substantial changes to the solution ( e.g. , conversion of the projects from legacy to SDK style), you need to delete bin and obj subdirectories beneath src as dotnet (and consequently MSBuild) will not do that for you. We provide a shallow script to save you a couple of keystrokes: .\\src\\RemoveBinAndObj.ps1 Reformatting Code We use dontet-format to automatically fix the formatting of the code to comply with the style guideline. To reformat the code in-place, call: .\\src\\FormatCode.ps1 Generate Doctests We use doctest-csharp for doctests . To extract the doctests and generate the corresponding unit tests: .\\src\\Doctest.ps1 Licenses We maintain one file listing all the copyrights and licenses, LICENSE.txt . This license file needs to be replicated in each of the solution projects. If there are changes to LICENSE.txt , propagate it to the projects by calling the following script: .\\src\\CopyLicenses.txt Running Checks Locally We wrote the checks in separate scripts ( e.g. , src\\CheckFormat.ps1 ) and bundled them in one script, src\\Check.ps1 . If you want to run all the checks, simply call: .\\src\\Check.ps1 The script src\\Check.ps1 will inform you which individual scripts were run. In case of failures, you can just run the last failing script. Please see the source code of src\\Check.ps1 for more details. Testing Locally with Test.ps1 Unit tests are part of our continuous integration. While you usually test with src\\Check.ps1 at the end of the development cycle, it is often practical to continuously test while developing. The script src\\Test.ps1 handles all the unit testing for you. Please note that you have to build the solution for debug before each run (using src\\BuildForDebug.ps1 ). src\\Test.ps1 will look for binaries in artefacts directory, and ignore any other binaries you might have built with your IDE ( e.g. , building from within Visual Studio will have no effect on src\\Test.ps1 execution!). To run all the tests: .\\src\\Test.ps1 To list the tests without executing them: .\\src\\Test.ps1 -Explore To execute an individual unit test: .\\src\\Test.ps1 -Test AasxDictionaryImport.Cdd.Tests.Test_Context.Empty You can also specify a prefix so that all the corresponding test cases will be executed: .\\src\\Test.ps1 -Test AasxDictionaryImport.Cdd Testing Locally with Visual Studio Our tests are written using NUnit3, so you need to install NUnit 3 Test Adapter for Visual Studio (see this article from NUnit documentation). See this article for how to use NUnit 3 Test Adapter in more detail. Once the adapter has been installed, you can run all the tests which do not require any external dependencies (such as AASX samples downloaded from http://admin-shell-io.com/samples/ ). Our tests with external dependencies use environment variables to specify the location of the dependencies. While src\\Check.ps1 and related scripts set up the expected locations in the environment automatically, you need to adjust your test setting accordingly. So far, we need to set SAMPLE_AASX_DIR environment variable to point to the absolute path where AASX samples have been downloaded (using src\\DownloadSamples.ps1 ). This is by definition {your repository}\\sample-aasx . In order to reflect this environment variable in your test adapter, you have to create a RUNSETTINGS file and include it into the solution as user-specific. Please follow this page from Visual Studio documentation how to set up a RUNSETTINGS file. Here is an example RUNSETTINGS file: <?xml version=\"1.0\" encoding=\"utf-8\"?> <RunSettings> <EnvironmentVariables> <SAMPLE_AASX_DIR> C:\\admin-shell-io\\aasx-package-explorer\\sample-aasx </SAMPLE_AASX_DIR> </EnvironmentVariables> </RunSettings> GUI Tests Analogous to unit tests, we provide GUI tests (a.k.a. function tests) based on FlaUI . Such test projects are marked with .GuiTests suffix. Mind that the tests run against the executables released in artefacts\\build\\Debug directory. This means that building the executables in your IDE will have no effect on GUI tests (unless you manually set the target for the binaries to artefacts\\build\\Debug ). Please always double-check that you built your binaries with src\\BuildForDebug.ps1 to avoid unnecessary confusion. Some of the GUI tests, similarly to unit tests, depend on sample AASX files which need to be downloaded with src\\DownloadSamples.ps1 before the tests can run. Once you built for debug and obtained the samples, you are all set to automatically test the GUIs. To run all the GUI tests, call: .\\src\\TestGui.ps1 Similar to unit tests, you can list the tests: .\\src\\Test.ps1 -Explore , execute a single test: .\\src\\TestGui.ps1 ` -Test AasxPackageExplorer.GuiTests.TestBasic.Test_application_start or a group of tests sharing a common prefix: .\\src\\TestGui.ps1 ` -Test AasxPackageExplorer.GuiTests GUI tests are not executed automatically on the remote CI servers. First, it is more often than difficult to run GUI tests on headless remote servers, so it would put a high maintenance burden. Second, GUI tests take too long and depend on timeouts which are often not controllable and reproducible enough. In particular, timeouts depend on the server load and hence can vary greatly. Github Workflows Github Actions allow for running continuous integration on Github servers. For a general introduction, see Github's documentation on Actions . The specification of our Github workflows can be found in .github/workflows directory. Please see the corresponding *.yml files for more details."
  },
  "getting-started/development-workflow.html": {
    "href": "getting-started/development-workflow.html",
    "title": "Development Workflow",
    "keywords": "Development Workflow We develop with Github using pull requests (see this Github guide for a short introduction). Development branch . The development branch is always master . Releases . The releases mark the development milestones on the master branch with a certain feature completeness. Pull Requests Feature branches . We develop using the feature branches, see this section of the Git book . If you are a member of the development team, create a feature branch directly within the repository. Otherwise, if you are a non-member contributor, fork the repository and create the feature branch in your forked repository. See this Github tuturial for more guidance. Branch Prefix . Please prefix the branch with your Github user name ( e.g., mristin/Add-some-feature ). Continuous Integration . Github will run the continuous integration (CI) automatically through Github actions. The CI includes building the solution, running the test, inspecting the code etc. (see below the section \"Pre-merge Checks\"). Please note that running the Github actions consumes computational resources which is often unnecessary if you are certain that some checks are not needed. For example, there is no need to build the whole solution if you only make a minor change in a powershell Script unrelated to building. You can manually disable workflows by appending the following lines to the body of the pull request (corresponding to which checks you want to disable): The workflow build-test-inspect was intentionally skipped. The workflow check-style was intentionally skipped. The workflow check-release was intentionally skipped. Commit Messages The commit messages follow the guidelines from https://chris.beams.io/posts/git-commit : Separate subject from body with a blank line Limit the subject line to 50 characters Capitalize the subject line Do not end the subject line with a period Use the imperative mood in the subject line Wrap the body at 72 characters Use the body to explain what and why (instead of how ) We automatically check the commit messages using opinionated-commit-message . Here is an example commit message (from this pull request ): Make DownloadSamples.ps1 use default proxy Using the default proxy is necessary so that DownloadSamples.ps1 can operate on enterprise networks which restrict the network traffic through the proxy. The workflow build-test-inspect was intentionally skipped. The workflow check-style was intentionally skipped. The workflow check-release was intentionally skipped."
  },
  "getting-started/installing-the-dependencies.html": {
    "href": "getting-started/installing-the-dependencies.html",
    "title": "Installing the Dependencies",
    "keywords": "Installing the Dependencies We provide PowerShell scripts to help you install the dependencies and build the solution from the command line. Tools for development . Most of the contributors use Visual Studio ( e.g. Visual Studio 2019 Community Edition), the go-to tool for C# and .NET development. If you are familiar with it, we would highly recommend you to use Visual Studio as well. Visual Studio comes with a set of build tools (Visual Studio Build Tools) and package manager (NuGet) included, so you do not need to install them yourself. However, if you want to set up a custom build server or develop using a custom editor ( e.g. , Vim) you can use the following script to install development tools such as Visual Studio Build Tools, NuGet etc .: .\\src\\InstallToolsForDevelopment.ps1 Mind that you need admin privileges in order to install these development tools. The script also provides an option for a dry run to list the tools without actually installing anything on the system (and does not require any admin privileges): .\\src\\InstallToolsForDevelopment.ps1 -DryRun Solution Dependencies . The solution relies on many solution-specific tools (such as a tool for code formatting) as well as third-party libraries. The solution dependencies are split into three different categories: Tools for the build-test-inspect workflow (such as Resharper CLI), Tools necessary to check the conformance of the code to the style guideline (such as dotnet-format), The third-party libraries (using NuGet) and Sample AASX packages used for integration testing (provided at http://admin-shell-io.com/samples/ ). The following script installs all the dependencies in one go: .\\src\\InstallSolutionDependencies.ps1 This script should not require any admin privileges. We also provide a script for each respective category which is called from within src\\InstallSolutionDependencies.ps1 : src\\InstallToolsForBuildTestInspect.ps1 src\\InstallToolsForStyle.ps1 , src\\InstallBuildDependencies.ps1 and src\\DownloadSamples.ps1 . The logic had to be separated so that individual workflows of the continuous integration would have only the dependencies installed that they actually need. This script should not require any admin privileges. Updating the dependencies . Whenever the dependencies change, the install script needs to be re-run: .\\src\\InstallSolutionDependencies.ps1 Obsolete dependencies will not be removed ( e.g. , unused NuGet packages in packages/ or AASX samples). You need to manually remove them."
  },
  "getting-started/intro.html": {
    "href": "getting-started/intro.html",
    "title": "Introduction",
    "keywords": "Introduction This series of articles help you set up and build the solution, explain you how to test and check your code contribution and finally how to properly submit it. If you don't like reading the documentation, just want to take a deep dive and start contributing, the following section \"Quick Start\" gives you a brief overview of how you can get your code in. Quick Start This is a brief list of steps explaining how to submit your code contribution. Development Tools Install the IDE of your choice, e.g. , Visual Studio 2019 Community Edition . Create a feature branch If you are a member of admin-shell-io GitHub organization : Clone the Git repository: git clone https://github.com/admin-shell-io/aasx-package-explorer Create your feature branch: git checkout -b yourUsername/Add-some-new-feature Please observe our guideline to naming the branches ( {your-username}/{Describe-subject-of-the-commit} ). Otherwise : Make the fork of your repository (see this GitHub guide ) Clone the Git repository: git clone https://github.com/yourUsername/aasx-package-explorer Create your feature branch: git checkout -b yourUsername/Add-some-new-feature Dependencies Change to the directory of your repository. Execute in Powershell: .\\src\\InstallSolutionDependencies.ps1 Write Your Code Make your code changes. Do not forget to implement unit tests. Commit & Push Format your code to conform to the style guide: .\\src\\FormatCode.ps1 Add files that you would like in your pull request: git add src/AasxSomeProject/SomeFile.cs Commit locally: git commit Please observe our guideline related to commit messages : First line is a subject, max. 50 characters, starts with a verb in imperative mood Empty line Body, max. line width 72 characters, must not start with the first word of the subject Run the pre-commit checks and make sure they all pass: .\\src\\Check.ps1 If needed, change your commit message: git commit --amend Set the upstream of your branch: git branch --set-upstream-to origin/yourUsername/Add-some-new-feature Push your changes: git push Pull Request Go to the aasx-package-explorer GitHub Repository and create the pull request in the web interface. Have it reviewed, if necessary Make sure all the remote checks pass Sign Contributor License Agreement (CLA) on the page of your pull request. This needs to be done only once. Merge If you are a member of admin-shell-io GitHub organization : Squash & Merge (see this section of the GitHub documentation ) Otherwise : Ask somebody from the organization to squash & merge the pull request for you Visual Studio - Solution structure The VS solution is structured in multiple folders Plugins: all plugin reside here Create a plugin As copying and renaming projects in Vs does not always work perfectly, here a step-by-step guidance: in Plugins, add a new project as .DLL for .net & WPF choose wisely a new name for the project, always starting with AasxPlugin.. location shall be below src/. select .net-framework = 4.6.1 copy an appropriate existing Plugin.cs (do NOT rename it!) copy an appropriate existing ...Options.cs (rename it, you WILL need options) add reference to AasxCsharpLibrary, AasxIntegrationBase, AasxIntegrationBaseWpf, AasxPredefinedConcepts in the ...Options.cs, check&modify the record-logic for allowing Submodel semantic ids choose an appropriate Submodel semantic id to be associated with the plugin change the contents of the Plugin.cs (do NOT rename it!) change handling of options defined in ...Options.cs file change ListActions() for the actions, your plugin shall handle (if an action is not listed, it will not be issued by the main application to the plug-in!) change / extend ActivateAction() to handle defined actions use string-comparison for action names always check & typecast provided arguments important actions are: \"call-check-visual-extension\": the main app calls this action for each Submodel to check, if the plug-in feels responsible \"get-events\": retrieves stacked events FROM the plugin \"event-return\": pushes events from the main app TO the plugin \"get-check-visual-extension\": returns a True, if a control shall be rendered \"fill-panel-visual-extension\": fill a provided WPF panel with content controls event payloads are defined in: AasxPluginInterface.cs"
  },
  "getting-started/licenses-and-copyrights.html": {
    "href": "getting-started/licenses-and-copyrights.html",
    "title": "Licenses and Copyrights",
    "keywords": "Licenses and Copyrights The file LICENSE.TXT in the main folder of the repo is the leading license information, even if it does not show up in the Visual Studio solution. To update all dependent license files, manually start src\\CopyLicense.ps1 . Some plug-ins require a separate license. These separate licenses are given in LICENSE-PLUGIN.txt in the corresponding directory of the plug-in. You should add a copyright note for each major contribution in the corresponding files: The copyright note should start with Copyright (c) followed by the time span of the contribution. You should put the full name of the legal entity ( e.g. , Phoenix Contact GmbH & Co. KG ); a simple name (Phoenix Contact) will not do! Each copyright note should indicate the contact to the legal entity in the angle brackets ( e.g. , <https://www.festo.com/net/de_de/Forms/web/contact_international> ). The author of the contribution is optional (unless the contributor is a private person, of course). If there are multiple authors, please indicate only the organization and omit the individual contributors. All the copyrights of a file are joined into a single comment block ( /* ... */ ). Reference all the used libraries and dependencies in the copyright block as well. Example copyright block in the source code: /* Copyright (c) 2018-2019 Festo AG & Co. KG <https://www.festo.com/net/de_de/Forms/web/contact_international> Author: Michael Hoffmeister Copyright (c) 2019-2020 PHOENIX CONTACT GmbH & Co. KG <opensource@phoenixcontact.com> Author: Andreas Orzelski The browser functionality is under the cefSharp license (see https://raw.githubusercontent.com/cefsharp/CefSharp/master/LICENSE). The JSON serialization is under the MIT license (see https://github.com/JamesNK/Newtonsoft.Json/blob/master/LICENSE.md). The QR code generation is under the MIT license (see https://github.com/codebude/QRCoder/blob/master/LICENSE.txt). The Dot Matrix Code (DMC) generation is under Apache license v2.0 (see http://www.apache.org/licenses/LICENSE-2.0). */ Please make sure to add the copyright notes in the main LICENSE.txt file as well and call src\\CopyLicense.ps1 on changes. The licenses of the dependencies have to be listed in the main LICENSE.txt as well. Example of the LICENSE.txt header: Copyright (c) 2018-2020 Festo AG & Co. KG <https://www.festo.com/net/de_de/Forms/web/contact_international> Author: Michael Hoffmeister Copyright (c) 2019-2020 PHOENIX CONTACT GmbH & Co. KG <opensource@phoenixcontact.com> Author: Andreas Orzelski Copyright (c) 2019-2020 Fraunhofer IOSB-INA Lemgo, eine rechtlich nicht selbstaendige Einrichtung der Fraunhofer-Gesellschaft zur Foerderung der angewandten Forschung e.V. Copyright (c) 2020 Schneider Electric Automation GmbH <marco.mendes@se.com> Author: Marco Mendes ... more contributors ... This software is licensed under the Apache License 2.0 (Apache-2.0) (see below) The browser functionality is licensed under the cefSharp license (see below) The QR code generation is licensed under the MIT license (MIT) (see below) ... more references to dependencies ... Example of the dependency license down in the body of LICENSE.txt: With respect to cefSharp ========================= (https://raw.githubusercontent.com/cefsharp/CefSharp/master/LICENSE) // Copyright © The CefSharp Authors. All rights reserved. // // Redistribution and use in source and binary forms, with or without // modification, are permitted provided that the following conditions are // met: ... Contributor License Agreement (CLA) Every contributor needs to sign the Contributor License Agreement (CLA). Thanks to CLA-assistant GitHub plug-in, this can be done on-line. You can see the CLA here: https://cla-assistant.io/admin-shell-io/aasx-package-explorer When you create a pull request, you will be automatically asked to sign the CLA. Simply click on the button, click that you agree to CLA and the agreement should be signed."
  },
  "getting-started/releasing.html": {
    "href": "getting-started/releasing.html",
    "title": "Releasing",
    "keywords": "Releasing Versioning We version based on the date of the release ( e.g. , 2019-10-21 ). The suffixes alpha and beta indicate the testing maturity of the release: Alpha releases have not been manually tested (only automatic tests were performed). Beta releases underwent only a bit of manual testing, but no thorough manual testing has been performed. A release without suffix implies that a couple of users tested the release and were satisfied with the quality of the software. While we admit that such a versioning scheme is uninformative with respect to number of new features, bugs fixed or critical changes, we found it too hard to come up with a versioning scheme for a GUI program such as ours that would be neither misleading nor confusing. Schemes like semantic versioning work well for libraries or command-line tools where breaking changes and extensions are well-defined. However, a breaking change in a GUI is not as easily defined and much more subjective ( e.g. , a breaking change for one user is a minor improvement to another user). Build Solution for Release To build the solution for release, invoke: .\\src\\BuildForRelease.ps1 If you want to clean a previous build, call: .\\src\\BuildForRelease.ps1 -clean This will produce the solution build in artefacts/ directory. In cases of substantial changes to the solution ( e.g. , conversion of the projects from legacy to SDK style), you need to delete bin and obj subdirectories beneath src as dotnet (and consequently MSBuild) will not do that for you. We provide a shallow script to save you a couple of keystrokes: .\\src\\RemoveBinAndObj.ps1 Package the Release The release is now ready to be packaged. Call PackageRelease.ps with the desired version: .\\src\\PackageRelease.ps1 -version 2020-08-14.alpha Multiple release packages will be produced (with web browser integrated, small etc .)."
  },
  "getting-started/troubleshooting.html": {
    "href": "getting-started/troubleshooting.html",
    "title": "Troubleshooting",
    "keywords": "Troubleshooting \"Execution of scripts is disabled on this system.\" If the Execution Policy of your system is not set to Unrestricted , you might not be able to directly execute the build scripts like Build.ps1 . Instead you have to use PowerShell's -ExecutionPolicy Bypass option. Example error: > .\\Build.ps1 .\\Build.ps1 : Die Datei \".\\Build.ps1\" kann nicht geladen werden, da die Ausführung von Skripts auf diesem System deaktiviert ist. Weitere Informationen finden Sie unter \"about_Execution_Policies\" (https:/go.microsoft.com/fwlink/?LinkID=135170). In Zeile:1 Zeichen:1 + .\\Build.ps1 + ~~~~~~~~~~~ + CategoryInfo : Sicherheitsfehler: (:) [], PSSecurityException + FullyQualifiedErrorId : UnauthorizedAccess Workaround: > powershell -ExecutionPolicy Bypass -File .\\Build.ps1 Unauthorized Access by NuGet If calls to NuGet or dotnet (for example in InstallBuildDependencies.ps1 ) fail with an Unauthorized Access error, you might have to configure NuGet to use your proxy. You can do so by setting NuGet's http_proxy and, if necessary, http_proxy.user config options. Workaround: > nuget.exe config -set http_proxy=http://<PROXY> > nuget.exe config -set http_proxy.user=<DOMAIN>\\<USER> Using Visual Studio's MSBuild executable If you have a Visual Studio installation on your machine, you can use Visual Studio's MSBuild executable instead of installing MSBuild using the InstallDevDependencies.ps1 script. The executable is located in the MSBuild\\Current\\Bin directory of your Visual Studio installation, typically C:\\Program Files (x86)\\Microsoft Visual Studio\\<Release>\\<Edition>\\MSBuild\\Current\\Bin . Make sure that this directory is listed in your PATH environment variable. Using rulers in Visual Studio Please see this Stack Overflow question and answers if you want Visual Studio to show rulers ( e.g. , at 120 characters): https://stackoverflow.com/questions/5887107/ruler-in-visual-studio In particular, we endorse this answer: https://stackoverflow.com/a/57904374/1600678"
  },
  "index.html": {
    "href": "index.html",
    "title": "Devdoc for AASX Project Explorer",
    "keywords": "Devdoc for AASX Project Explorer This is the documentation for the contributors and developers of AASX Project Explorer. For the general introduction and the description of the tool, please see the Github repository: https://github.com/admin-shell-io/aasx-package-explorer . The documentation is split in two sections: Getting Started explain how to set up & build the solution, run continuous integration and submit your contribution. API Documentation goes through the code base and presents the documentation of individual code units (classes, methods etc. )."
  }
}